from Crypto.Util.number import *

p1 = 1527207470243143973741530105910986024271649986608148657294882537828034327858594844987775446712917007186537829119357070864918869
p2 = 2019864244456120206428956645997068464122219855220655920467990311571156191223237121636244541173449544034684177250532278907347407
p3 = 1801109020443617827324680638861937237596639325730371475055693399143628803572030079812427637295108153858392360647248339418361407
c1 = 232762450308730030838415167305062079887914561751502831059133765333100914083329837666753704309116795944107100966648563183291808
c2 = 869189375217585206857269997483379374418043159436598804873841035147176525138665409890054486560412505207030359232633223629185304
c3 = 1465704473460472286244828683610388110862719231828602162838215555887249333131331510519650513265133531691347657992103108331793683

n = p1*p2*p3
n1 = n//p1
n2 = n//p2
n3 = n//p3

r1 = inverse(n1,p1)
r2 = inverse(n2,p2)
r3 = inverse(n3,p3)

flag = (c1*n1*r1+c2*n2*r2+c3*n3*r3)%n
flag = long_to_bytes(flag)
print(flag.decode('latin1')) #'utf-8'도 가능하다
pow(n1,n2,n3) 
#n1^n2 mod n3를 구하는 함수


# (a*x) mod m = 1 일때 inverse(a,m) = x 를 통해서 모듈러 역원을 구할 수 있다.






